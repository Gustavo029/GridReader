import sys,os,io
sys.path.append(os.path.join(os.path.dirname(__file__), os.path.pardir))
from PyEFVLib import MSHReader, Grid, ProblemData, CgnsSaver, CsvSaver, NeumannBoundaryCondition, DirichletBoundaryCondition
from apps.heat_transfer import heatTransfer
from apps.stress_equilibrium import stressEquilibrium

import tkinter as tk
from tkinter import filedialog, ttk, messagebox, scrolledtext

import matplotlib
matplotlib.use("TkAgg")
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib import pyplot as plt
from matplotlib import cm
from matplotlib.colors import ListedColormap as CM, Normalize

from contextlib import redirect_stdout
import numpy as np
from numpy import pi, sin, cos, tan, arcsin, arccos, arctan, sinh, cosh, tanh, arcsinh, arccosh, arctanh, sqrt, e , log, exp, inf, mod, floor
import pandas as pd
from scipy.interpolate import griddata

def getFunction(expr):
	def function(x,y,z,t):
		return eval( expr.replace('x',str(x)).replace('y',str(y)).replace('z',str(z)).replace('t',str(t)) )
	return function

class PyEFVLibGUI:
	def __init__(self):
		self.root = tk.Tk()
		self.root.title("PyEFVLib GUI")
		self.root.iconbitmap("icon.ico")
		self.root.bind("<Key>", lambda key: self.root.destroy() if key.char=="\x17" else 0) # Close window if Ctrl+W is pressed

		self.HEIGHT, self.WIDTH = (500, 600)

		self.init()

		self.root.mainloop()

	def init(self):
		self.mainMenu = MainMenu(self.root, self)
		self.heatTransferApplication = HeatTransferApplication(self.root, self)
		self.solidMechanicsApplication = SolidMechanicsApplication(self.root, self)
		self.post = Post(self.root, self)

		self.mainMenu.init()

class MainMenu:
	def __init__(self, root, application):
		self.root = root
		self.app = application

	def init(self):
		self.populate()
		self.show()

	def populate(self):
		self.page = tk.Frame(self.root, width=300, height=250)
		# self.page = tk.Frame(self.root, width=300, height=250)
		centerFrame = tk.Frame(self.page)

		heatTransferButton = tk.Button(centerFrame, text="Heat Transfer Application", command=self.openHeatTransfer)
		heatTransferButton.bind('<Return>', lambda e:self.openHeatTransfer())
		heatTransferButton.grid(row=0, sticky=["w","e"])

		solidMechanicsButton = tk.Button(centerFrame, text="Solid Mechanics Application", command=self.openSolidMechanics)
		solidMechanicsButton.bind('<Return>', lambda e:self.openSolidMechanics())
		solidMechanicsButton.grid(row=1, sticky=["w","e"])

		postButton = tk.Button(centerFrame, text="Post", command=self.openPost)
		postButton.bind('<Return>', lambda e:self.openPost())
		postButton.grid(row=2, sticky=["w","e"])

		centerFrame.place(relx=0.5, rely=0.35-0.02, anchor="n")

	def show(self):
		self.page.pack(side="top", fill="both", expand=1)

	def openHeatTransfer(self):
		self.page.destroy()
		self.app.heatTransferApplication.init()

	def openSolidMechanics(self):
		self.page.destroy()
		self.app.solidMechanicsApplication.init()

	def openPost(self):
		messagebox.showinfo("Select a result file", "Select a file generated by PyEFVLib simulation")
		initialdir = os.path.join(os.path.dirname(__file__), os.path.pardir, "results")
		resultsFileName = tk.filedialog.askopenfilename(initialdir=initialdir, title="Select a result file", filetypes=(("CSV files", "*.csv"),("All files", "*")))
		if resultsFileName:
			self.page.destroy()
			self.app.post.setResultsPath( os.path.realpath( resultsFileName ) )
			self.app.post.init()

class Page(tk.Canvas):
	def __init__(self, root, width, height, prevFunc, nextFunc):
		tk.Canvas.__init__(self, root, width=width, height=height)
		self.root = root
		self.prevFunc = prevFunc
		self.nextFunc = nextFunc

		self.placeFooter()

	def placeFooter(self):
		self.footerFrame = tk.Frame(self)
		self.footerFrame.place(relx=0.02, rely=1.00-0.02, relwidth=1.00-0.04, relheight=0.10-0.02, anchor="sw")

		self.prevButton = tk.Button(self.footerFrame, text="Prev", command=self.prevFunc)
		self.prevButton.bind('<Return>', lambda e:self.prevFunc())
		self.prevButton.place(relx=0.80-0.02, rely=0.50, relheight=0.75, relwidth=0.20, anchor="e")

		self.nextButton = tk.Button(self.footerFrame, text="Next", command=self.nextFunc)
		self.nextButton.bind('<Return>', lambda e:self.nextFunc())
		self.nextButton.place(relx=1.0, rely=0.50, relheight=0.75, relwidth=0.20, anchor="e")

	def show(self):
		self.pack(side="left", fill="both", expand=1)

	def hide(self):
		self.pack_forget()

class Application:
	def __init__(self, root, application):
		self.root = root
		self.app = application
		self.settings()

	def init(self):
		self.meshFileName = ""
		self.simulated = False
		self.drawn = False

		self.populatePage1()
		self.page1.show()

	def populatePage1(self):
		self.page1 = Page(self.root, height=500, width=600, prevFunc=self.page1Prev, nextFunc=self.page1Next)

		self.openFrame = tk.LabelFrame(self.page1, text="Open Mesh File")
		self.openFrame.place(relx=0.02, rely=0.02, relheight=0.20-0.02, relwidth=1.00-0.04, anchor="nw")

		openButton = tk.Button(self.openFrame, text="Open Mesh File", command=self.openFile)
		openButton.bind('<Return>', lambda e:self.openFile())
		openButton.place(relx=0.02, rely=0.5, relheight=0.50, relwidth=0.25, anchor="w")

		self.fileLabel = tk.Label(self.openFrame, text="", bg="white", anchor="e")
		self.fileLabel.place(relx=0.30, rely=0.5, relheight=0.50, relwidth=0.65, anchor="w")

		self.BCFrame = tk.LabelFrame(self.page1, text="Boundary Conditions Settings")
		self.BCFrame.place(relx=0.02, rely=0.20+0.02, relheight=0.65-0.02, relwidth=1.00-0.04, anchor="nw")

		def showBoundariesFunc():
			if self.showFigVar.get():
				self.showMeshVar.set(False)
				self.hideBCMesh()
				self.showBCFig()
			else:
				self.hideBCFig()
		def showMeshFunc():
			if self.showMeshVar.get():
				self.showFigVar.set(False)
				self.hideBCFig()
				self.showBCMesh()
			else:
				self.hideBCMesh()

		self.showFigVar = tk.BooleanVar()
		self.showFigVar.set(False)
		self.showFigCheckbox = tk.Checkbutton(self.page1.footerFrame, text="Show Boundaries", variable=self.showFigVar, command=showBoundariesFunc, state="disabled")
		self.showFigCheckbox.place(relx=0.0, rely=0.25, anchor="w")
		self.showMeshVar = tk.BooleanVar()
		self.showMeshVar.set(False)
		self.showMeshCheckbox = tk.Checkbutton(self.page1.footerFrame, text="Show Mesh", variable=self.showMeshVar, command=showMeshFunc, state="disabled")
		self.showMeshCheckbox.place(relx=0.0, rely=0.75, anchor="w")

	def populatePage2(self):
		self.page2 = Page(self.root, height=500, width=600, prevFunc=self.page2Prev, nextFunc=self.page2Next)
		# Property Frame

		self.propertyEntries = dict()
		self.propertyUnitVars = dict()
		self.propertiesFrames = []
		self.currentRegion = 0

		numberOfRegions = len(self.meshData.regionsNames)

		def nextRegion():
			if self.currentRegion < numberOfRegions-1:
				self.propertiesFrames[self.currentRegion].place_forget()
				self.propertiesFrames[self.currentRegion+1].place(relx=0.02, rely=0.02, relheight=0.81, relwidth=1.00-0.04, anchor="nw")
				self.currentRegion += 1
		def prevRegion():
			if self.currentRegion > 0:
				self.propertiesFrames[self.currentRegion].place_forget()
				self.propertiesFrames[self.currentRegion-1].place(relx=0.02, rely=0.02, relheight=0.81, relwidth=1.00-0.04, anchor="nw")
				self.currentRegion -= 1
		def insertProperties(materialName):
			currentRegionName = self.meshData.regionsNames[self.currentRegion]
			for propertyName in self.materials[materialName].keys():
				self.propertyEntries[currentRegionName][propertyName].delete( 0, tk.END )
				self.propertyEntries[currentRegionName][propertyName].insert( tk.END, self.materials[materialName][propertyName] )
				self.propertyUnitVars[currentRegionName][propertyName].set(self.propertyUnits[propertyName][0])

		for regionCount, region in enumerate(self.meshData.regionsNames):
			propertiesFrame = tk.LabelFrame(self.page2, text="Material Properties")
			self.propertiesFrames.append(propertiesFrame)
			centerFrame = tk.Frame(propertiesFrame)

			self.propertyEntries[region] = dict()
			self.propertyUnitVars[region] = dict()

			self.regionCountLabel = tk.Label(centerFrame, text=f"{region}\t[{regionCount+1}/{numberOfRegions}]")
			self.regionCountLabel.grid(row=0, column=0, pady=5, sticky="W")

			tk.Label(centerFrame, text="Material Database:").grid(row=0, column=4)
			materialsTable = tk.OptionMenu(centerFrame, tk.StringVar(value="Select Material"), *self.materials.keys(), command=lambda propertyName:insertProperties(propertyName))#, region))
			materialsTable.grid(row=0, column=5, sticky="nswe")

			i=1
			for propertyName in self.properties:
				options = self.propertyUnits[propertyName]

				unitVar = tk.StringVar(centerFrame)
				unitVar.set(self.propertyUnits[propertyName][0])
				bTypeVar = tk.IntVar(centerFrame)

				nameLabel = ttk.Label(centerFrame, text=propertyName)
				nameLabel.grid(row=i, column=0, sticky="W", padx=5)

				valEntry = ttk.Entry(centerFrame)
				valEntry.grid(row=i,column=1)

				unitMenu = tk.OptionMenu(centerFrame, unitVar, *options)
				unitMenu.grid(row=i, column=2, sticky="E")


				self.propertyEntries[region][propertyName] = valEntry
				self.propertyUnitVars[region][propertyName] = unitVar
				i+=1

			prevButton = tk.Button(centerFrame, text="<", command=prevRegion, state="disabled" if numberOfRegions==1 or regionCount==0 else "normal")
			prevButton.bind('<Return>', lambda e:prevRegion())
			prevButton.grid(row=i, column=2, sticky="E")

			nextButton = tk.Button(centerFrame, text=">", command=nextRegion, state="disabled" if numberOfRegions==1 or regionCount==numberOfRegions-1 else "normal")
			nextButton.bind('<Return>', lambda e:nextRegion())
			nextButton.grid(row=i, column=3, sticky="W")

			centerFrame.place(relx=0.02, rely=0.0, anchor="nw")

		self.propertiesFrames[0].place(relx=0.02, rely=0.02, relheight=0.45, relwidth=1.00-0.04, anchor="nw")
		
		# Numerical Frame
		numericalFrame = tk.LabelFrame(self.page2, text="Numerical Settings")

		# Help Button
		if "temperature" in self.fields:
			def spaninfo():
				# This variable indicates whether it was possible to calculate h and alpha.
				# This prevents the "?" button to scream at the user for not filled the 
				# 	entries properly
				gotParameters = False

				regionName = self.meshData.regionsNames[self.currentRegion]
				if not True in [entry.get() == "" for entry in self.propertyEntries[regionName].values()]:
					try:
						h = ( sum([element.volume for element in self.grid.elements])/self.grid.elements.size ) ** (1/self.grid.dimension)

						k = float( self.propertyEntries[regionName]["Conductivity"].get() )
						rho = float( self.propertyEntries[regionName]["Density"].get() )
						cp = float( self.propertyEntries[regionName]["HeatCapacity"].get() )
						
						k   = self.unitsConvert[ self.propertyUnitVars[regionName]["Conductivity"].get() ](k)
						rho = self.unitsConvert[ self.propertyUnitVars[regionName]["Density"].get() ](rho)
						cp  = self.unitsConvert[ self.propertyUnitVars[regionName]["HeatCapacity"].get() ](cp)
						
						alpha = k / (rho * cp)
						
						gotParameters = True
					except: 
						# Note that when expression properties get implemented,
						# this will throw an error here
						print("Properties parameters have not been properly filled yet")

				if gotParameters:
					messagebox.showinfo("Help", f"{regionName} info.\nCharacteristic mesh length (h) = {h:.03e} m\nDiffusivity (α=k/(ρ cp) = {alpha:.03e} m²/s\nParameter for timeStep (h²/α) = {h**2/alpha:.03e} s")
				else:
					messagebox.showinfo("Help", f"Fill in {regionName} properties to see its diffusivity and characteristic mesh length")
			
			infobox = tk.Button(numericalFrame, text="  ?  ", command=spaninfo)
			infobox.place(relx=0.96, rely=0.0, anchor="ne")

		# Numerical Settings
		self.numericalSettingsEntries = []
		self.numericalSettingsUnits = []
		self.numericalSettingsUnitMenus = []
		self.numericalSettingsBools = []
		self.numericalSettingsCheckboxes = []

		def toggleCheckbox(i):
			def toggleCheckboxFunc():
				setting = list(self.numericalSettingsOp.keys())[i]
				state = self.numericalSettingsBools[i].get()

				if setting != "Transient":
					# Entry
					if self.numericalSettingsOp[setting]["option"][0]:
						if state:
							self.numericalSettingsEntries[i].grid(row=i, column=1, padx=5, pady=5, sticky="W")
						else:
							self.numericalSettingsEntries[i].grid_forget()
					# Unit
					if self.numericalSettingsOp[setting]["option"][1]:
						if state:
							self.numericalSettingsUnitMenus[i].grid(row=i, column=2, sticky="E")
						else:
							self.numericalSettingsUnitMenus[i].grid_forget()
				else:
					if state:
						j=0
						for loopSetting, entry, unitMenu, boolVar, checkbox in zip( self.numericalSettingsOp.keys(), self.numericalSettingsEntries, self.numericalSettingsUnitMenus, self.numericalSettingsBools, self.numericalSettingsCheckboxes ):
							if self.numericalSettingsOp[loopSetting]["option"][0] and self.numericalSettingsOp[loopSetting]["option"][3]:
								entry.grid(row=j, column=1, padx=5, pady=5, sticky="W")
							
							if self.numericalSettingsOp[loopSetting]["option"][1] and self.numericalSettingsOp[loopSetting]["option"][3]:
								unitMenu.grid(row=j, column=2, sticky="E")
							boolVar.set(self.numericalSettingsOp[loopSetting]["option"][3])
							if loopSetting != "Time Step":
								checkbox.configure(state="normal")
							j+=1
					else:
						for loopSetting, entry, unitMenu, boolVar, checkbox in zip( self.numericalSettingsOp.keys(), self.numericalSettingsEntries, self.numericalSettingsUnitMenus, self.numericalSettingsBools, self.numericalSettingsCheckboxes ):
							if loopSetting != "Transient":
								entry.grid_forget()
								unitMenu.grid_forget()
								boolVar.set(False)
								checkbox.configure(state="disabled")

			return toggleCheckboxFunc

		i=0
		for setting in self.numericalSettingsOp.keys():
			# Label
			label = tk.Label(numericalFrame, text=setting)
			label.grid(row=i, column=0, padx=5, pady=5, sticky="W")

			# Entry
			entry = tk.Entry(numericalFrame)
			if self.numericalSettingsOp[setting]["option"][0] and self.numericalSettingsOp[setting]["option"][3]:
				entry.grid(row=i, column=1, padx=5, pady=5, sticky="W")

			self.numericalSettingsEntries.append(entry)

			# Unit
			unitVar = tk.StringVar(numericalFrame)
			unitVar.set(self.numericalSettingsOp[setting]["units"][0])

			unitMenu = tk.OptionMenu(numericalFrame, unitVar, *self.numericalSettingsOp[setting]["units"])
			if self.numericalSettingsOp[setting]["option"][1] and self.numericalSettingsOp[setting]["option"][3]:
				unitMenu.grid(row=i, column=2, sticky="E")

			self.numericalSettingsUnits.append(unitVar)
			self.numericalSettingsUnitMenus.append(unitMenu)

			# Checkbox
			boolVar = tk.BooleanVar()
			boolVar.set(self.numericalSettingsOp[setting]["option"][3])

			checkbox = tk.Checkbutton(numericalFrame, variable=boolVar, command=toggleCheckbox(i), state= "normal" if self.numericalSettingsOp[setting]["option"][2] else "disabled")
			checkbox.grid(row=i, column=3)

			self.numericalSettingsBools.append(boolVar)
			self.numericalSettingsCheckboxes.append(checkbox)

			i+=1

		numericalFrame.place(relx=0.02, rely=0.45+0.02, relheight=0.40-0.02, relwidth=1.00-0.04, anchor="nw")

		self.populated = True      
  
	def populateBCFrame(self):
		self.boundariesNames = self.meshData.boundariesNames
		self.currentField = 0
		fieldsBCCanvas = []
		fieldsIValueFrames = []
		fieldsBCWindows = dict()

		self.boundaryUnitVars		= dict()
		self.boundaryTypeVars		= dict()
		self.boundaryValueEntries	= dict()
		self.boundaryUnitMenus		= dict()

		self.initialValueEntries	= dict()
		self.initialValueUnitVars	= dict()

		def chooseNeumannRadioButton(i, field): #
			def chooseNeumannRadioButtonFunc():
				unitVar = self.boundaryUnitVars[field][i]
				optionMenu = self.boundaryUnitMenus[field][i]

				unitVar.set("")
				optionMenu["menu"].delete(0,"end") # remove full list 
				for opt in self.neumannUnits[field]: 
					optionMenu['menu'].add_command(label=opt, command=tk._setit(unitVar, opt))
				unitVar.set(self.neumannUnits[field][0]) # default value set 

			return chooseNeumannRadioButtonFunc
		def chooseDirichletRadioButton(i, field): #
			def chooseDirichletRadioButtonFunc():
				unitVar = self.boundaryUnitVars[field][i]
				optionMenu = self.boundaryUnitMenus[field][i]

				unitVar.set("")
				optionMenu["menu"].delete(0,"end") # remove full list 
				for opt in self.dirichletUnits[field]: 
					optionMenu['menu'].add_command(label=opt, command=tk._setit(unitVar, opt))
				unitVar.set(self.dirichletUnits[field][0]) # default value set 
			return chooseDirichletRadioButtonFunc
		def prevField():
			if self.currentField > 0:
				fieldsBCCanvas[self.currentField].place_forget()
				fieldsIValueFrames[self.currentField].place_forget()
				self.currentField -= 1
				fieldsBCCanvas[self.currentField].place(relx=0.0, rely=0.0, relwidth=1.0, relheight=0.85, anchor="nw")
				fieldsIValueFrames[self.currentField].place(relx=0.0, rely=0.85, relwidth=1.0, relheight=0.15, anchor="nw")
				self.BCFrame.configure(text="Boundary Conditions Settings - {} [{}/{}]".format( self.fields[self.currentField] , self.currentField+1, len(self.fields)))
		def nextField():
			if self.currentField < len(self.fields)-1:
				fieldsBCCanvas[self.currentField].place_forget()
				fieldsIValueFrames[self.currentField].place_forget()
				self.currentField += 1
				fieldsBCCanvas[self.currentField].place(relx=0.0, rely=0.0, relwidth=1.0, relheight=0.85, anchor="nw")
				fieldsIValueFrames[self.currentField].place(relx=0.0, rely=0.85, relwidth=1.0, relheight=0.15, anchor="nw")
				self.BCFrame.configure(text="Boundary Conditions Settings - {} [{}/{}]".format( self.fields[self.currentField] , self.currentField+1, len(self.fields)))
		def placeStatic(field):
			BCCanvas = tk.Canvas(self.BCFrame)
			fieldsBCCanvas.append(BCCanvas)

			scrollbar = ttk.Scrollbar(self.BCFrame, orient="vertical", command=BCCanvas.yview)
			scrollbar.place(relx=1.0, rely=0.0, relheight=0.85, anchor="ne")

			# with Windows OS
			self.root.bind("<MouseWheel>", lambda e: BCCanvas.yview_scroll(-1*int(e.delta/120), "units"))
			# with Linux OS
			self.root.bind("<Button-4>", lambda e: BCCanvas.yview_scroll(-1, "units"))
			self.root.bind("<Button-5>", lambda e: BCCanvas.yview_scroll(+1, "units"))

			BCWindow = ttk.Frame(BCCanvas)
			BCWindow.bind("<Configure>", lambda event: BCCanvas.configure(scrollregion=BCCanvas.bbox("all")))

			BCCanvas.create_window((0, 0), window=BCWindow, anchor="nw")
			BCCanvas.configure(yscrollcommand=scrollbar.set)

			BCWindow.columnconfigure(index=0, pad=5)
			BCWindow.columnconfigure(index=1, pad=5)
			BCWindow.columnconfigure(index=2, pad=5)
			BCWindow.columnconfigure(index=3, pad=5)
			BCWindow.rowconfigure(index=0, pad=5)
			BCWindow.rowconfigure(index=1, pad=5)
			BCWindow.rowconfigure(index=2, pad=5)
			BCWindow.rowconfigure(index=3, pad=5)

			ttk.Label(BCWindow, text="Boundary Name").grid(row=0, column=0)
			ttk.Label(BCWindow, text="Value").grid(row=0, column=1)
			ttk.Label(BCWindow, text="Unit").grid(row=0, column=2)
			ttk.Label(BCWindow, text="  Neumann BC  ").grid(row=0, column=3)
			ttk.Label(BCWindow, text="  Dirichlet BC  ").grid(row=0, column=4)
			
			fieldsBCWindows[field] = BCWindow
		def placeInputs(field):
			# Obs.: If 3D then neumann units are [Temp]/[Distance^2]
			BCWindow = fieldsBCWindows[field]
			self.boundaryUnitVars[field]		  = []
			self.boundaryTypeVars[field]		  = []
			self.boundaryValueEntries[field]	  = []
			self.boundaryUnitMenus[field]		  = []

			i=1
			for boundaryName in self.boundariesNames:
				options = []

				unitVar = tk.StringVar(BCWindow)
				unitVar.set("")
				bTypeVar = tk.IntVar(BCWindow)

				nameLabel = ttk.Label(BCWindow, text=boundaryName)
				nameLabel.grid(row=i, column=0, padx=5, sticky="W")

				unitMenu = ttk.OptionMenu(BCWindow, unitVar, *options)
				unitMenu.grid(row=i, column=2, sticky="E")

				neumannButton = tk.Radiobutton(BCWindow, variable=bTypeVar, value=1, command=chooseNeumannRadioButton(i-1, field))
				neumannButton.grid(row=i, column=3)

				dirichletButton = tk.Radiobutton(BCWindow, variable=bTypeVar, value=2, command=chooseDirichletRadioButton(i-1, field))
				dirichletButton.grid(row=i, column=4)

				self.boundaryUnitVars[field].append(unitVar)
				self.boundaryTypeVars[field].append(bTypeVar)
				self.boundaryUnitMenus[field].append(unitMenu)

				i+=1
			i=1
			for boundaryName in self.boundariesNames:
				valEntry = tk.Entry(BCWindow)
				valEntry.grid(row=i,column=1)
				self.boundaryValueEntries[field].append(valEntry)

				i+=1
		def placeInitialValue(field):
			initialValueFrame = tk.LabelFrame(self.BCFrame)
			fieldsIValueFrames.append(initialValueFrame)

			initialValueLabel = tk.Label(initialValueFrame, text="Frame's\ninitial value")
			initialValueLabel.place(relx=0.0, rely=0.5, anchor="w")

			self.initialValueEntries[field] = tk.Entry(initialValueFrame)
			self.initialValueEntries[field].place(x=100, rely=0.5, anchor="w")

			self.initialValueUnitVars[field] = tk.StringVar(initialValueFrame)
			self.initialValueUnitVars[field].set("")

			unitMenu = ttk.OptionMenu(initialValueFrame, self.initialValueUnitVars[field], *self.dirichletUnits[field])
			unitMenu.place(x=270, rely=0.5, anchor="w")

			prevButton = tk.Button(initialValueFrame, text="  <  ", command=prevField, state="disabled" if field == self.fields[0] else "normal")
			prevButton.bind('<Return>', lambda e:prevField())
			prevButton.place(relx=0.9, rely=0.5, anchor="e")

			nextButton = tk.Button(initialValueFrame, text="  >  ", command=nextField, state="disabled" if field == self.fields[-1] else "normal")
			nextButton.bind('<Return>', lambda e:nextField())
			nextButton.place(relx=0.9, rely=0.5, anchor="w")

		for field in self.fields:
			placeStatic(field)
			placeInputs(field)
			placeInitialValue(field)

		fieldsBCCanvas[0].place(relx=0.0, rely=0.0, relwidth=1.0, relheight=0.85, anchor="nw")
		fieldsIValueFrames[0].place(relx=0.0, rely=0.85, relwidth=1.0, relheight=0.15, anchor="nw")
		self.BCFrame.configure(text="Boundary Conditions Settings - {} [{}/{}]".format( self.fields[self.currentField] , self.currentField+1, len(self.fields)))

	def populateBCFig(self):
		self.drawn = True
		self.figDrawCanvas = tk.Canvas(self.root, width=600, height=500)

		figure = matplotlib.figure.Figure()
		plot = figure.add_subplot()

		i=0
		for boundary, boundaryName in zip(self.meshData.boundariesIndexes, self.meshData.boundariesNames):
			boundaryColor = plt.cm.get_cmap("hsv", len(self.meshData.boundariesNames))(i)
			for facet in boundary:
				pair = self.meshData.boundariesConnectivities[facet]
				coords = [self.meshData.vertices[v][:-1] for v in pair]
				plot.plot(*zip(*coords), color=boundaryColor, label=boundaryName if facet==boundary[0] else None)

			i+=1
		plot.legend()
		canvas = FigureCanvasTkAgg(figure, self.figDrawCanvas)
		canvas.get_tk_widget().pack(side="left", fill="both", expand=1)

	def populateBCMesh(self):
		self.drawn = True
		self.meshDrawCanvas = tk.Canvas(self.root, width=600, height=500)

		figure = matplotlib.figure.Figure()
		plot = figure.add_subplot()

		for element in self.meshData.elementsConnectivities:
			x,y,z = zip(*[self.meshData.vertices[vertexIdx] for vertexIdx in element+[element[0]] ])
			plot.plot(x,y,color="k")

		canvas = FigureCanvasTkAgg(figure, self.meshDrawCanvas)
		canvas.get_tk_widget().pack(side="left", fill="both", expand=1)

	def showBCFig(self):
		self.figDrawCanvas.pack(side="left", fill="both", expand=1)

	def showBCMesh(self):
		self.meshDrawCanvas.pack(side="left", fill="both", expand=1)

	def hideBCFig(self):
		self.figDrawCanvas.pack_forget()

	def hideBCMesh(self):
		self.meshDrawCanvas.pack_forget()

	def page1Prev(self):
		self.page1.destroy()
		self.app.init()
		# self.app.mainMenu.init()
	
	def page1Next(self):
		self.checkFile()
		self.page1.hide()
		self.hideBCFig()
		self.hideBCMesh()
		self.page2.show()
	
	def page2Prev(self):
		self.page2.hide()
		self.page1.show()
	
	def page2Next(self):
		simulate = True
		if self.simulated:
			if "no" == tk.messagebox.askquestion("Warning", "A simulation has already been calculated. Do you want to calculate another one?"):
				simulate = False
				self.page2.hide()
				self.app.post.consolePage.show()
				return

		if simulate:
			self.checkPage1Data()
			self.checkPage2Data()
			self.runSimulation()
			self.simulated = True

			self.page2.hide()
			self.app.post.setResultsPath(os.path.join(os.path.dirname(__file__), os.path.pardir, "results", "gui", "Results.csv"))
			self.app.post.init()

	def openFile(self):
		initialdir = os.path.join( os.path.dirname(__file__), os.path.pardir, "meshes" )
		prevMeshFileName = self.meshFileName
		self.meshFileName = tk.filedialog.askopenfilename(initialdir=initialdir, title="Select a mesh file", filetypes=(("MSH files", "*.msh"),("All files", "*")))

		if self.meshFileName: # Prevents against not choosing a file
			if not ".msh" in self.meshFileName:
				# Prevents from forgetting already selected mesh if select mesh button is accidentally pressed
				self.meshFileName = prevMeshFileName
				messagebox.showwarning("Warning","Must be a .msh file")
				raise Exception("Must be a .msh file")
			try:
				self.meshData = MSHReader(self.meshFileName).getData()
			except:
				# Prevents from forgetting already selected mesh if select mesh button is accidentally pressed
				self.meshFileName = prevMeshFileName
				messagebox.showwarning("Warning","Invalid mesh file")
				raise Exception("Invalid mesh file")
			

			self.grid = Grid( self.meshData )
			if self.grid.dimension == 2:
				if self.drawn:
					self.figDrawCanvas.destroy()
				self.showFigCheckbox.configure(state="normal")
				self.showMeshCheckbox.configure(state="normal")
				self.populateBCFig()
				self.populateBCMesh()

			self.fileLabel["text"] = self.meshFileName
			self.populateBCFrame()
			self.populatePage2()
		else:
			self.meshFileName = prevMeshFileName

	def checkFile(self):
		if not self.meshFileName:
			messagebox.showwarning("Warning","Must Select a mesh File")
			raise Exception("Must select a mesh file")

	def checkPage1Data(self):
		for field in self.fields:
			for boundaryName, entry, bType in zip(self.boundariesNames, self.boundaryValueEntries[field], self.boundaryTypeVars[field]):
				BCExpression = entry.get()
				try:
					float( BCExpression )
				except:
					try:
						# Try to parse expression
						getFunction( BCExpression )( *np.random.rand((4)) )
					except:
						messagebox.showwarning("Warning","Invalid value in \"{} - {}\" field".format(field, boundaryName))
						raise Exception("Invalid value in \"{} - {}\" field".format(field, boundaryName))
				if bType.get() == 0:
					messagebox.showwarning("Warning","Must select either Neumann or Dirichlet Boundary Condition")
					raise Exception("Must select either Neumann or Dirichlet Boundary Condition")
			initialExpression = self.initialValueEntries[field].get()
			try:
				float( initialExpression )
			except:
				try:
					# Try to parse expression
					getFunction( initialExpression )( *np.random.rand((4)) )
				except:
					messagebox.showwarning("Warning", "Invalid Value in Initial Value field")
					raise Exception("Invalid Value in Initial Value field")
	
	def checkPage2Data(self):
		for region in self.meshData.regionsNames:
			for propertyName in self.properties:
					propertyValue = self.propertyEntries[region][propertyName].get()
					try:
						float( propertyValue )
					except:
						messagebox.showwarning("Warning", "Invalid value in \"{}\" {} field".format(region, propertyName))
						raise Exception("Invalid value in \"{}\" {} field".format(region, propertyName))
	
		transientIndex = list(self.numericalSettingsOp.keys()).index("Transient")
		finalTimeIndex = list(self.numericalSettingsOp.keys()).index("Final time")
		numberOfTSIndex = list(self.numericalSettingsOp.keys()).index("Max number of time steps")
		toleranceIndex = list(self.numericalSettingsOp.keys()).index("Tolerance")
		
		if self.numericalSettingsBools[transientIndex].get():
			if not self.numericalSettingsBools[finalTimeIndex].get() and not self.numericalSettingsBools[numberOfTSIndex].get() and not self.numericalSettingsBools[toleranceIndex].get():
				messagebox.showwarning("Warning", "There is no way of reaching convergence. Set at least one of final time, max number of iterations or tolerance fields")
				raise Exception("There is no way of reaching convergence. Set at least one of final time, max number of iterations or tolerance fields")

		i=0
		for numericalSetting in self.numericalSettingsOp.keys():
			if self.numericalSettingsOp[numericalSetting]["option"][0] and self.numericalSettingsBools[i].get():
				try:
					float( self.numericalSettingsEntries[i].get() )
					if float( self.numericalSettingsEntries[i].get() ) <= 0.0:
						self.numericalSettingsEntries[i].delete( 0, tk.END )
						raise Exception("Warning", "Numerical settings must be positive")
				except:
					messagebox.showwarning("Warning", "Invalid input in {} field".format(numericalSetting))
					raise Exception("Invalid input in {} field".format(numericalSetting))
			i+=1

	def quit(self):
		self.root.destroy()

class SolidMechanicsApplication(Application):
	def settings(self):
		self.fields = ["u", "v"]

		self.neumannUnits = {"u": ["Pa", "kPa", "MPa", "GPa", "kgf/m²", "psi"], "v": ["Pa", "kPa", "MPa", "GPa", "kgf/m²", "psi"]}
		self.dirichletUnits = {"u": ["m", "mm", "cm", "μm", "inch"], "v": ["m", "mm", "cm", "μm", "inch"]}

		self.properties = ["Density", "PoissonsRatio", "ShearModulus", "Gravity"]
		self.propertyUnits = {
			"Density"		: ["kg/m³", "g/cm³"], 		
			"PoissonsRatio" : [""], 
			"ShearModulus"	: ["MPa", "GPa", "kPa", "Pa", "psi"], 
			"Gravity"		: ["m/s²", "mm/s²", "km/h²"]

		}

		self.numericalSettingsOp = {	# "option": [entry, unit, checkbox]
			"Time Step"					:{"option":[1,1,0,0],"units":["s", "min", "h", "days", "weeks"]},
			"Final time"				:{"option":[1,1,0,0],"units":["s", "min", "h", "days", "weeks"]},
			"Max number of time steps"	:{"option":[1,0,0,0],"units":[""]},
			"Tolerance"					:{"option":[1,1,0,0],"units":["K"]},
			"Transient"					:{"option":[0,0,0,0],"units":[""]}
		}

		self.unitsConvert = {
			"m"		: lambda x: x,
			"mm"		: lambda x: 0.001*x,
			"cm"		: lambda x: 0.01*x,
			"μm"		: lambda x: 1e-06*x,
			"inch"		: lambda x: 0.0254*x,
			"kg/m³"		: lambda rho: rho,
			"g/cm³"		: lambda rho: 1000.0*rho,
			""			: lambda _: _,
			"MPa"		: lambda P: 1e+06*P,
			"kgf/m²"	: lambda P: 9.807*P,
			"GPa"		: lambda P: 1e+09*P,
			"kPa"		: lambda P: 1e+03*P,
			"Pa"		: lambda P: P,
			"psi"		: lambda P: 6894.757*P,
			"m/s²"		: lambda a: a,
			"mm/s²"		: lambda a: 0.001*a,
			"km/h²"		: lambda a: 7.716e-05*a,
			"s"			: lambda t: t,
			"min"		: lambda t: 60.0*t,
			"h"			: lambda t: 3600*t,
			"days"		: lambda t: 86400.0*t,
			"weeks"		: lambda t: 604800.0*t,
		}

		self.materials = {
			"Select material": { "Density": "", "PoissonsRatio": "", "ShearModulus": "", "Gravity": "" },
			"Material 01": { "Density": 2400, "PoissonsRatio": 0.33, "ShearModulus": 6.0, "Gravity": -9.81 },

		}

	def runSimulation(self):
		if self.grid.dimension != 2:
			messagebox.showwarning("Warning","Stress Equilibrium Problem not implemented yet for 3D cases")
			self.quit()
			raise Exception("Stress Equilibrium Problem not implemented yet for 3D cases")

		# Boundary Conditions
		initialValues = { field : self.unitsConvert[ self.initialValueUnitVars[field].get() ](float( self.initialValueEntries[field].get() )) for field in self.fields}
		
		neumannBoundaries = dict()
		dirichletBoundaries = dict()
		boundaryConditionsDict = {bName : dict() for bName in self.boundariesNames}

		for field in self.fields:
			neumannBoundaries[field] = []
			dirichletBoundaries[field] = []
			handle = 0

			for bName, boundary, entry, unit, bType in zip(self.boundariesNames, self.grid.boundaries, self.boundaryValueEntries[field], self.boundaryUnitVars[field], self.boundaryTypeVars[field]):
				value = self.unitsConvert[unit.get()]( float( entry.get() ) )
				if bType.get() == 1:
					bc = NeumannBoundaryCondition(self.grid, boundary, value, handle)
					neumannBoundaries[field].append(bc)
				if bType.get() == 2:
					bc = DirichletBoundaryCondition(self.grid, boundary, value, handle)
					dirichletBoundaries[field].append(bc)
				boundaryConditionsDict[bName][field] = bc
				handle += 1

		# Property Data
		self.propertyData = []
		for region in self.grid.regions:
			self.propertyData.append( dict() )
			for propertyName in self.propertyEntries[region.name].keys():
				self.propertyData[-1][propertyName] = float( self.propertyEntries[region.name][propertyName].get() )
				self.propertyData[-1][propertyName] = self.unitsConvert[ self.propertyUnitVars[region.name][propertyName].get() ]( self.propertyData[-1][propertyName] )

		stressEquilibrium(
			libraryPath = os.path.join(os.path.dirname(__file__), os.path.pardir),
			outputPath = os.path.join(os.path.dirname(__file__), os.path.pardir, "results", "gui"),
			extension = "csv",
			
			grid 	  = self.grid,
			propertyData = self.propertyData,

			initialValues = initialValues,
			neumannBoundaries = neumannBoundaries,
			dirichletBoundaries = dirichletBoundaries,
			boundaryConditions = list(boundaryConditionsDict.values()),

			verbosity=True 
		)

class HeatTransferApplication(Application):
	def settings(self):
		self.fields = ["temperature"]

		self.neumannUnits = {"temperature": ["K/m"]}
		self.dirichletUnits = {"temperature": ["K", "°C", "°F"]}
		
		self.properties = ["Density","HeatCapacity","Conductivity","HeatGeneration"]
		self.propertyUnits = {
			"Density":        ["kg/m³", "g/cm³"],
			"HeatCapacity":   ["J/kg.K"],
			"Conductivity":   ["W/m.K"],
			"HeatGeneration": ["K/m³"]
		}

		self.numericalSettingsOp = {	# "option": [entry, unit, checkbox]
			"Time Step"					:{"option":[1,1,0,1],"units":["s", "min", "h", "days", "weeks"]},
			"Final time"				:{"option":[1,1,1,0],"units":["s", "min", "h", "days", "weeks"]},
			"Max number of time steps"	:{"option":[1,0,1,1],"units":[""]},
			"Tolerance"					:{"option":[1,1,1,0],"units":["K"]},
			"Transient"					:{"option":[0,0,1,1],"units":[""]}
		}

		self.unitsConvert = {
			"K"		: lambda T: T,
			"°C"	: lambda T: T+273.15,
			"°F"	: lambda T: 5.0*(T-32.0)/9.0+273.15,
			"K/m"	: lambda d: d,
			"kg/m³"	: lambda rho: rho,
			"g/cm³"	: lambda rho: 1000.0*rho,
			"J/kg.K": lambda Cp: Cp,
			"W/m.K"	: lambda k: k,
			"K/m³"	: lambda q: q,
			"s"		: lambda t: t,
			"min"	: lambda t: 60.0*t,
			"h"		: lambda t: 3600*t,
			"days"	: lambda t: 86400.0*t,
			"weeks"	: lambda t: 604800.0*t,
		}

		self.materials = {
			"Select material": { "Density": "", "HeatCapacity": "", "Conductivity": "", "HeatGeneration": "" },
			"Material 01": { "Density": 1200, "HeatCapacity": 300, "Conductivity": 30, "HeatGeneration": 0.0 },

		}

	def runSimulation(self):
		# Boundary Conditions
		boundaryConditionsData = dict()
		for bName, entry, unit, bType in zip(self.boundariesNames, self.boundaryValueEntries["temperature"], self.boundaryUnitVars["temperature"], self.boundaryTypeVars["temperature"]):
			boundaryConditionsData[bName] = {
				"condition": ["NEUMANN", "DIRICHLET"][bType.get()-1],
				"type": "CONSTANT",
				"value": float( entry.get() )
			}

		initialValues = {"temperature": [float(self.initialValueEntries["temperature"].get())] * self.grid.vertices.size},
		neumannBoundaries = {"temperature":[NeumannBoundaryCondition(self.grid, boundary, boundaryConditionsData[boundary.name]["value"], handle) for handle, boundary in enumerate(self.grid.boundaries) if boundaryConditionsData[boundary.name]["condition"] == "NEUMANN"]},
		dirichletBoundaries = {"temperature":[DirichletBoundaryCondition(self.grid, boundary, boundaryConditionsData[boundary.name]["value"], handle) for handle, boundary in enumerate(self.grid.boundaries) if boundaryConditionsData[boundary.name]["condition"] == "DIRICHLET"]}

		# Property Data
		self.propertyData = []
		for region in self.grid.regions:
			self.propertyData.append( dict() )
			for propertyName in self.propertyEntries[region.name].keys():
				self.propertyData[-1][propertyName] = float( self.propertyEntries[region.name][propertyName].get() )
				self.propertyData[-1][propertyName] = self.unitsConvert[ self.propertyUnitVars[region.name][propertyName].get() ]( self.propertyData[-1][propertyName] )

		# Numerical Settings
		index = list(self.numericalSettingsOp.keys()).index("Time Step")
		if self.numericalSettingsBools[index].get():
			timeStep  = float(self.numericalSettingsEntries[index].get())
			timeStep  = self.unitsConvert[ self.numericalSettingsUnits[index].get() ](timeStep) 
		else:
			timeStep = 0.0

		index = list(self.numericalSettingsOp.keys()).index("Final time")
		if self.numericalSettingsBools[index].get():
			finalTime = float(self.numericalSettingsEntries[index].get())
			finalTime  = self.unitsConvert[ self.numericalSettingsUnits[index].get() ](finalTime) 
		else:
			finalTime = None

		index = list(self.numericalSettingsOp.keys()).index("Max number of time steps")
		if self.numericalSettingsBools[index].get():
			maxNumberOfTimeSteps = float(self.numericalSettingsEntries[index].get())
		else:
			maxNumberOfTimeSteps = None

		index = list(self.numericalSettingsOp.keys()).index("Tolerance")
		if self.numericalSettingsBools[index].get():
			tolerance = float(self.numericalSettingsEntries[index].get())
		else:
			tolerance = None

		transient = self.numericalSettingsBools[list(self.numericalSettingsOp.keys()).index("Transient")].get()

		f = io.StringIO()		
		with redirect_stdout(f):
			print("\n{:>9}\t{:>14}\t{:>14}\t{:>14}".format("Iteration", "CurrentTime", "TimeStep", "Difference"))
			heatTransfer(
				libraryPath = os.path.join(os.path.dirname(__file__), os.path.pardir),
				outputPath = os.path.join(os.path.dirname(__file__), os.path.pardir, "results", "gui"),
				extension = "csv",
				
				grid 	  = self.grid,
				propertyData = self.propertyData,
				
				initialValues = {"temperature": [ self.unitsConvert[self.initialValueUnitVars["temperature"].get()]( float(self.initialValueEntries["temperature"].get()) ) ] * self.grid.vertices.size},
				neumannBoundaries = {"temperature":[NeumannBoundaryCondition(self.grid, boundary, boundaryConditionsData[boundary.name]["value"], handle) for handle, boundary in enumerate(self.grid.boundaries) if boundaryConditionsData[boundary.name]["condition"] == "NEUMANN"]},
				dirichletBoundaries = {"temperature":[DirichletBoundaryCondition(self.grid, boundary, boundaryConditionsData[boundary.name]["value"], handle) for handle, boundary in enumerate(self.grid.boundaries) if boundaryConditionsData[boundary.name]["condition"] == "DIRICHLET"]},
	 
				timeStep  = timeStep ,
				finalTime = finalTime,
				maxNumberOfIterations = maxNumberOfTimeSteps,
				tolerance = tolerance,
				
				transient = transient,
				verbosity = True,
				color=False
			)

		self.app.post.setOutputTextVar(f)

class Post:
	def __init__(self, root, application):
		self.root = root
		self.app = application
		self.settings()

	def settings(self):
		self.first = True
		self.consoleTextSet = False

	def init(self):
		self.readData()
		self.populateConsole()
		self.populatePage1()
		self.populatePage2()

		if self.consoleTextSet:
			self.consolePage.show()
		else:
			self.page1.show()

	def populateConsole(self):
		def prevFunc():
			self.consolePage.hide()
			self.app.heatTransferApplication.page2.show()
		def nextFunc():
			self.consolePage.hide()
			self.page1.show()

		self.consolePage = Page(self.root, width=600, height=500, prevFunc=prevFunc, nextFunc=nextFunc)

		tk.Label(self.consolePage, text="Console:").place(relx=0.02, rely=0.02, anchor="nw")

		if self.consoleTextSet:
			outputText = scrolledtext.ScrolledText(self.consolePage)
			outputText.insert(tk.END, self.outputTextVar.getvalue())
			outputText.configure(state="disabled")
			outputText.place(relx=0.02, rely=0.02+0.05, relheight=0.80, relwidth=1.00-0.04, anchor="nw" )

	def populatePage1(self):
		self.page1 = Page(self.root, width=600, height=500, prevFunc=self.page1Prev,nextFunc=self.page1Next)
		# Settings
		def changeTSStringVar():
			self.timeStepStrVar.set( self.timeSteps[ self.timeStepVar.get()-1 ] )
		def slideTSIntVar(value):
			self.timeStepVar.set( round(float( value )) )
			changeTSStringVar()

		self.CMSettingsFrame = tk.LabelFrame(self.page1, text="Colormap Settings")

		centerFrame = tk.Frame(self.CMSettingsFrame)

		timeStepLabel = tk.Label(centerFrame, text="Time Step:")
		timeStepLabel.grid(row=0, column=0, padx=5, pady=5, sticky="w")

		self.timeStepVar = tk.IntVar(value=self.numberOfTimeSteps)
		
		timeStepBox = tk.Spinbox(centerFrame, textvariable=self.timeStepVar, from_=1, to=self.numberOfTimeSteps, width=5, state="readonly" if self.numberOfTimeSteps > 1 else "disabled")
		timeStepBox.grid(row=0, column=2, pady=5)

		timeStepSlider = ttk.Scale(centerFrame, from_=1, to=self.numberOfTimeSteps, orient="horizontal", variable=self.timeStepVar, command=slideTSIntVar)
		timeStepSlider.grid(row=0, column=1, padx=5, pady=5)

		maxTimeStepLabel = tk.Label(centerFrame, text=f"/{self.numberOfTimeSteps}")
		maxTimeStepLabel.grid(row=0, column=3, pady=5)

		tk.Label(centerFrame).grid(row=1, column=3, padx=5)
		showButton = tk.Button(centerFrame, text="Show", command=self.showColorMap)
		showButton.bind('<Return>', lambda e:self.showColorMap())
		showButton.grid(row=0, column=4, padx=5, pady=5, sticky="e")

		fieldLabel = tk.Label(centerFrame, text="Field:")
		fieldLabel.grid(row=1, column=0, padx=5, pady=5, sticky="w")

		self.fieldVar = tk.StringVar()
		self.fieldVar.set(self.fields[0])

		fieldMenu = tk.OptionMenu(centerFrame, self.fieldVar, *self.fields)
		fieldMenu.grid(row=1, column=1, columnspan=4, padx=5, pady=5, sticky="e")

		centerFrame.place(relx=0.5, rely=0.0, anchor="n")
		self.CMSettingsFrame.place(relx=0.02,rely=0.65,relwidth=1.00-0.04,relheight=0.25-0.02,anchor="nw")

		# Colormap

		self.colormapCanvas = tk.Canvas(self.page1)

		self.figure1 = matplotlib.figure.Figure()
		self.plot1 = self.figure1.add_subplot()
		self.plot1.set_position([0.125,0.15,0.75,0.75])


		self.figure1.patch.set_facecolor((240/255,240/255,237/255))
		self.plot1.patch.set_facecolor((240/255,240/255,237/255))

		self.plot1.set_xlabel("x [m]")
		self.plot1.set_ylabel("y [m]")

		self.matplotlibCanvas1 = FigureCanvasTkAgg(self.figure1, self.colormapCanvas)
		self.matplotlibCanvas1.get_tk_widget().pack(side="left", fill="both", expand=1)

		self.colormapCanvas.place(relx=0.02,rely=0.02,relwidth=1.00-0.04,relheight=0.65-0.04,anchor="nw")

	def populatePage2(self):
		self.page2 = Page(self.root, width=600, height=500, prevFunc=self.page2Prev, nextFunc=lambda:1)
		self.page2.nextButton.configure(state="disabled")

		def changeTSIntVar(stringVal):
			self.timeStepVar.set( int(stringVal.replace("TimeStep", "")) )

		# Settings

		self.PPSettingsFrame = tk.LabelFrame(self.page2, text="Profile Plot Settings")

		centerFrame = tk.Frame(self.PPSettingsFrame)

		self.directionVar = tk.StringVar(value="y")

		directionMenu = tk.OptionMenu(centerFrame, self.directionVar, *["x", "y"])
		directionMenu.grid(row=0, column=0, padx=5, pady=5)

		tk.Label(centerFrame, text="=").grid(row=0,column=1,padx=5,pady=5)
		tk.Label(centerFrame, text="±").grid(row=0,column=3,padx=5,pady=5)

		self.lineEntry = tk.Entry(centerFrame, width=10)
		self.lineEntry.grid(row=0, column=2, padx=5, pady=5)

		self.devEntry = tk.Entry(centerFrame, width=10)
		self.devEntry.grid(row=0, column=4, padx=5, pady=5)
		self.devEntry.bind('<Return>', lambda e:self.plotFieldProfile())

		fieldMenu = tk.OptionMenu(centerFrame, self.fieldVar, *self.fields)
		fieldMenu.grid(row=1, column=0, columnspan=3, padx=5, pady=5, sticky="w")

		self.timeStepStrVar = tk.StringVar(value=self.timeSteps[-1])
		timeStepMenu = tk.OptionMenu(centerFrame, self.timeStepStrVar, command=changeTSIntVar, *self.timeSteps)
		timeStepMenu.grid(row=1, column=4, columnspan=2, padx=5, pady=5, sticky="e")

		plotButton = tk.Button(centerFrame, text="Plot", command=self.plotFieldProfile)
		plotButton.bind('<Return>', lambda e:self.plotFieldProfile())
		plotButton.grid(row=0, column=5, padx=5, pady=5, sticky="e")

		centerFrame.place(relx=0.5, rely=0.0, anchor="n")
		self.PPSettingsFrame.place(relx=0.02,rely=0.65,relwidth=1.00-0.04,relheight=0.25-0.02,anchor="nw")

		# Plot

		self.plotCanvas = tk.Canvas(self.page2)

		self.figure2 = matplotlib.figure.Figure()
		self.plot2 = self.figure2.add_subplot()
		self.plot2.set_position([0.125,0.15,0.8,0.75])

		self.figure2.patch.set_facecolor((240/255,240/255,237/255))
		self.plot2.patch.set_facecolor((240/255,240/255,237/255))

		self.plot2.set_title("Plot field along line")

		self.matplotlibCanvas2 = FigureCanvasTkAgg(self.figure2, self.plotCanvas)
		self.matplotlibWidget = self.matplotlibCanvas2.get_tk_widget()
		self.matplotlibWidget.pack(side="left", fill="both", expand=1)

		self.plotCanvas.place(relx=0.02,rely=0.02,relwidth=1.00-0.04,relheight=0.65-0.04,anchor="nw")

	def showColorMap(self):
		X,Y = self.coords[:-1]

		try:
			if int( self.timeStepVar.get() ) > self.numberOfTimeSteps or int( self.timeStepVar.get() ) < 1:
				raise Exception
		except:
			messagebox.showwarning("Warning", "Invalid Time Step\nIt must range from 1 to {}".format(self.numberOfTimeSteps))
			raise Exception("Invalid Time Step")

		label = "TimeStep{} - {}".format( self.timeStepVar.get(), self.fieldVar.get())
		numericalField = self.resultsData[label]

		Xi, Yi = np.meshgrid( np.linspace(min(X), max(X), len(X)), np.linspace(min(Y), max(Y), len(Y)) )
		nF = griddata((X,Y), numericalField, (Xi,Yi), method="linear")

		if self.first:
			self.first = False
		else:
			self.cbar.remove()
		try:
			self.cdata = self.plot1.pcolor(Xi,Yi,nF, cmap=CM( cm.get_cmap("RdBu",64)(np.linspace(1,0,64)) )) # Makes BuRd instead of RdBu
		except:
			messagebox.showerror("Error", "Unable to allocate the memory")
			raise Exception("Unable to allocate the memory")
		
		cbaxes = self.figure1.add_axes([0.90, 0.15, 0.03, 0.75]) 
		self.cbar = self.figure1.colorbar(self.cdata, cax=cbaxes)

		self.plot1.set_position([0.125,0.15,0.75,0.75])
		self.matplotlibCanvas1.draw()

	def page1Prev(self):
		self.page1.hide()
		if self.consoleTextSet:
			self.consolePage.show()
		else:
			self.app.init()

	def page1Next(self):
		self.page1.hide()
		self.page2.show()

	def page2Prev(self):
		self.page2.hide()
		self.page1.show()

	def setResultsPath(self, path):
		self.resultsPath = path
		self.root.title("PyEFVLib GUI - {}".format(path))

	def setOutputTextVar(self, textVar):
		self.outputTextVar = textVar
		self.consoleTextSet = True

	def plotFieldProfile(self):
		X,Y = self.coords[:-1]

		label = "{} - {}".format( self.timeStepStrVar.get(), self.fieldVar.get())

		try:
			w0 = float( self.lineEntry.get() )
			if self.devEntry.get() == "":
				dw = 0.0
			else:
				dw = float( self.devEntry.get() )
		except:
			messagebox.showwarning("Warning", "Invalid parameters")
			raise Exception("Invalid parameters")

		self.plot2.clear()
		self.plot2.patch.set_facecolor((240/255,240/255,237/255))

		# try:
		wStr = self.directionVar.get()
		tStr = "x" if wStr == "y" else "y"

		W = {"x": X, "y": Y}[wStr]
		T = {"x": X, "y": Y}[tStr]

		# Here w represents the chosen axis, and t the other one
		if w0-dw > max(W) or w0+dw < min(W):
			messagebox.showwarning("Warning", "This range does not contain the domain")
			return
		data = [(t, nR) for w,t,nR in zip(W, T, self.resultsData[label]) if abs(w-w0)<dw]
		if not data:
			messagebox.showwarning("Warning", "No point passes through this range")
			return
		T, numericalField = zip(*data)
		T, numericalField = zip(*sorted(zip(T,numericalField)))
		self.plot2.plot(T,numericalField, color="k", marker=".")

		self.plot2.set_xlim([min(T), max(T)])
		self.plot2.set_ylim([min(self.resultsData[label]), max(self.resultsData[label])])		
		self.plot2.set_xlabel(f"{tStr} [m]")
		self.plot2.set_ylabel(self.fieldVar.get())
		self.matplotlibCanvas2.draw()

		# except:
		# 	messagebox.showerror("Error", "An error has occuried")

	def readData(self):
		self.resultsData = pd.read_csv(self.resultsPath)
		self.coords = np.array(self.resultsData[["X","Y","Z"]]).T
		self.fields = list( {"".join(fieldName.split(" - ")[1:]) for fieldName in self.resultsData.columns[3:]} )
		self.timeSteps = [ fieldName.split(" - ")[0] for fieldName in self.resultsData.columns[3:] ]
		self.timeSteps = [ ts for idx, ts in enumerate(self.timeSteps) if ts not in self.timeSteps[:idx] ]
		self.numberOfTimeSteps = len(self.timeSteps)



if __name__ == "__main__":
	app = PyEFVLibGUI()
